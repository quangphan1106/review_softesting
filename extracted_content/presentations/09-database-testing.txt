
--- Page 1 ---
  Viet  Nam  National  University  Ho  Chi  Minh  City  University  of  Science    
CS423  –  Software  Testing  REPORT  
DATABASE  TESTING  TOOLS  
  22TT  –  Group  20  
Le  Quoc  Huy    22125031  Tran  Quang  Huy   22125032  Vo  Lan     22125047  Le  Huu  Nghia    22125064  
 
 
   October  21,  2025        

--- Page 2 ---
  
Table  of  Contents  
I  -  Introduction ....................................................................................................................................... 4 1.  Overview  of  Data  and  Database .................................................................................................... 4 a.  Data ......................................................................................................................................... 4 b.  Database .................................................................................................................................. 4 2.  Overview  of  Database  Testing ....................................................................................................... 4 3.  Why  is  Database  Testing  Important? ............................................................................................. 4 4.  Advantages  and  Disadvantages  of  Database  Testing .................................................................... 5 a.  Advantages .............................................................................................................................. 5 b.  Disadvantages ......................................................................................................................... 6 II  -  Database  Testing  Process ................................................................................................................ 6 1.  Stages  of  DB  Testing ..................................................................................................................... 6 2.  How  to  test  the  Database ............................................................................................................... 7 a.  Manual  Approach .................................................................................................................... 7 b.  Automation  Approach ............................................................................................................. 7 c.  Manual  vs.  Automated  Comparison ........................................................................................ 8 3.  How  to  write  test  cases .................................................................................................................. 8 a.  Basic  Principles ....................................................................................................................... 8 b.  Structure  of  a  Test  Case .......................................................................................................... 9 c.  Example  Test  Case  Objectives ................................................................................................ 9 III  -  Types  of  Database  Testing ........................................................................................................... 10 1.  Structural  Testing ......................................................................................................................... 10 a.  Table  and  Column  Validation ................................................................................................ 10 b.  Index  Testing ......................................................................................................................... 11 c.  Data  Migration  Testing .......................................................................................................... 12 d.  Database  Server  Validation ................................................................................................... 12 2.  Functional  Testing ....................................................................................................................... 13 a.  Data  Retrieval  Testing ........................................................................................................... 13 b.  Data  Manipulation  Testing .................................................................................................... 14 c.  Transaction  Testing ............................................................................................................... 14 d.  Stored  Procedures  and  Function  Testing ............................................................................... 15 3.  Non-functional  Testing ................................................................................................................ 16 a.  Performance  Testing .............................................................................................................. 16 b.  Load  Testing .......................................................................................................................... 16 c.  Stress  Testing ......................................................................................................................... 17 d.  Security  Testing ..................................................................................................................... 17 IV  -  Database  Testing  Tools ................................................................................................................. 17 1.  Core  Testing  Tools ....................................................................................................................... 17 a.  DBUnit .................................................................................................................................. 17 
--- Page 3 ---
b.  Maven .................................................................................................................................... 18 2.  Test  Data  Generation ................................................................................................................... 19 a.  The  Need  for  Data  Generation  Tools .................................................................................... 19 b.  Mockaroo .............................................................................................................................. 19 3.  Demonstration  Workflow:  Mockaroo  +  DBUnit  +  Maven ......................................................... 19 4.  Best  Practices ............................................................................................................................... 20 a.  Dataset  Management ............................................................................................................. 20 b.  Test  Design ............................................................................................................................ 20 c.  Data  Generation ..................................................................................................................... 20 References ............................................................................................................................................. 21 
  
--- Page 4 ---
I  -  Introduction  1.  Overview  of  Data  and  Database  To  understand  database  testing,  one  must  first  be  familiar  with  the  terms  "data"  and  "database."  
a.  Data  
Data  is  the  term  that  signifies  the  facts,  statistics,  and  information  that  software  processes,  manages,  
and
 
stores.
 
It
 
includes
 
elements
 
like
 
records,
 
tables,
 
columns,
 
and
 
indexes.
 
In
 
software
 
development,
 
this
 
can
 
be
 
user
 
inputs,
 
files,
 
or
 
configuration
 
data.
 
Data  is  divided  into  two  major  types:  ●  Unstructured  data:  This  data  does  not  have  any  defined  format  and  is  generally  disorganized  
(e.g.,
 
text
 
documents,
 
images,
 
audio
 
files,
 
videos).
 
It
 
is
 
common
 
in
 
applications
 
associated
 
with
 
text
 
processing
 
or
 
user-generated
 
content.
 ●  Structured  data:  This  is  information  that  is  organized  and  has  a  defined  format  and  structure  
(e.g.,
 
names,
 
addresses,
 
financial
 
transactions).
 
It
 
is
 
commonly
 
used
 
in
 
Relational
 
Database
 
Management
 
Systems
 
(RDBMS)
 
like
 
MySQL,
 
PostgreSQL,
 
and
 
Oracle.
 
b.  Database  
A  database  is  an  organized  collection  of  the  above-mentioned  data,  stored  for  easy  access  and  
manipulation
 
by
 
a
 
system.
 
Data
 
is
 
organized
 
into
 
tables,
 
rows,
 
indexes,
 
and
 
columns,
 
which
 
helps
 
users
 
to
 
quickly
 
identify
 
the
 
required
 
information.
 
Databases
 
use
 
tables
 
for
 
data
 
retention,
 
functions
 
and
 
triggers
 
for
 
data
 
manipulation,
 
and
 
views
 
for
 
data
 
presentation.
 
2.  Overview  of  Database  Testing  Database  Testing ,  also  referred  to  as  back-end  testing  or  data  testing ,  is  a  process  where  developers  
and
 
testers
 
ensure
 
the
 
quality,
 
accuracy,
 
and
 
security
 
of
 
the
 
data
 
stored
 
in
 
a
 
database.
 
In  simple  terms,  it  involves  verifying  the  data  within  a  database  by  assessing  the  software  components  
that
 
influence
 
the
 
data
 
and
 
its
 
associated
 
functionalities.
 
It
 
is
 
a
 
critical
 
part
 
of
 
the
 
testing
 
phase,
 
as
 
every
 
application
 
stores
 
large
 
amounts
 
of
 
crucial
 
data
 
(e.g.,
 
personal
 
information,
 
financial
 
records,
 
transaction
 
histories).
 
Unlike  traditional  application  testing  that  focuses  primarily  on  the  user  interface  and  front-end  
functionality,
 
database
 
testing
 
delves
 
into
 
the
 
back-end
 
layer
 
where
 
data
 
is
 
stored,
 
processed,
 
and
 
retrieved.
 
Here
 
are
 
some
 
key
 
points
 
on
 
database
 
testing:
 
●  It  evaluates  aspects  like  the  schema,  tables,  or  triggers  and  tests  data  integrity  and  consistency.  ●  Testers  often  create  complex  queries  to  perform  load  or  stress  tests  on  the  database.  ●  It  involves  a  layered  approach  encompassing  the  data  access,  User  Interface  (UI),  business,  
and
 
database
 
layers.
 ●  Common  tests  include  data  validity  checks,  data  integrity  tests,  performance  checks,  and  
testing
 
for
 
procedures
 
and
 
triggers.
 
3.  Why  is  Database  Testing  Important?  
--- Page 5 ---
A  fully  functional  database  is  essential  for  the  adequate  performance  of  software  applications.  If  data  
integrity
 
is
 
impacted,
 
it
 
can
 
cause
 
monetary
 
loss
 
to
 
the
 
organization,
 
lead
 
to
 
errors
 
in
 
decision-making,
 
operational
 
inefficiencies,
 
and
 
security
 
breaches.
 
Database  testing  is  imperative  to  handle  and  manage  data  effectively.  The  key  aspects  it  addresses  
include:
 ●  Data  mapping:  Database  testing  verifies  that  information  entered  through  front-end  forms  or  
other
 
input
 
methods
 
is
 
accurately
 
mapped
 
to
 
the
 
corresponding
 
fields
 
in
 
the
 
database
 
tables.
 
This
 
ensures
 
that
 
data
 
flows
 
correctly
 
from
 
the
 
application
 
interface
 
into
 
the
 
backend
 
storage,
 
preventing
 
misalignment
 
or
 
loss
 
of
 
critical
 
information.
 ●  Data  accuracy:  Testing  ensures  that  all  data  stored  in  the  database  is  accurate,  complete,  and  
adheres
 
strictly
 
to
 
predefined
 
business
 
rules
 
and
 
data
 
types.
 
This
 
includes
 
checking
 
for
 
valid
 
formats,
 
correct
 
numerical
 
values,
 
proper
 
string
 
lengths,
 
and
 
the
 
enforcement
 
of
 
constraints
 
to
 
maintain
 
data
 
integrity
 
throughout
 
the
 
system.
 ●  Data  security:  Database  testing  evaluates  the  security  mechanisms  implemented  to  safeguard  
sensitive
 
information.
 
Testers
 
identify
 
potential
 
vulnerabilities,
 
such
 
as
 
SQL
 
injection,
 
unauthorized
 
access,
 
or
 
accidental
 
data
 
leakage,
 
and
 
verify
 
that
 
appropriate
 
protective
 
measures
 
are
 
in
 
place
 
to
 
maintain
 
the
 
confidentiality
 
and
 
integrity
 
of
 
data.
 ●  Validating  Business  Rule  Accuracy:  For  complex  database  systems,  testing  includes  
validating
 
that
 
all
 
relational
 
constraints,
 
triggers,
 
stored
 
procedures,
 
and
 
other
 
automated
 
processes
 
operate
 
according
 
to
 
defined
 
business
 
rules.
 
SQL
 
queries
 
and
 
scripts
 
are
 
often
 
used
 
to
 
check
 
these
 
components,
 
ensuring
 
that
 
the
 
database
 
enforces
 
correct
 
workflows,
 
calculations,
 
and
 
dependencies.
 ●  Seamless  data  migration:  When  data  is  transferred  from  one  database  system  or  version  to  
another,
 
database
 
testing
 
ensures
 
that
 
the
 
migration
 
process
 
preserves
 
data
 
accuracy,
 
completeness,
 
and
 
integrity.
 
It
 
helps
 
identify
 
inconsistencies
 
or
 
losses
 
during
 
transfer,
 
providing
 
confidence
 
that
 
the
 
new
 
environment
 
reflects
 
the
 
original
 
data
 
correctly.
 ●  Data  transformation:  In  ETL  (Extract,  Transform,  Load)  processes,  database  testing  is  
critical
 
to
 
validate
 
data
 
transformation
 
rules,
 
integration
 
logic,
 
and
 
consistency
 
across
 
systems.
 
This
 
involves
 
checking
 
that
 
data
 
extracted
 
from
 
source
 
systems
 
is
 
correctly
 
transformed
 
and
 
loaded
 
into
 
target
 
databases,
 
preserving
 
meaning,
 
format,
 
and
 
relationships
 
throughout
 
the
 
process.
 
4.  Advantages  and  Disadvantages  of  Database  Testing  
a.  Advantages  
●  Early  Error  Detection:  Database  testing  allows  teams  to  identify  defects  and  inconsistencies  
during
 
the
 
early
 
stages
 
of
 
development.
 
Detecting
 
errors
 
at
 
this
 
point
 
not
 
only
 
reduces
 
the
 
cost
 
of
 
fixing
 
them
 
but
 
also
 
prevents
 
these
 
issues
 
from
 
propagating
 
into
 
later
 
stages
 
of
 
the
 
project,
 
where
 
the
 
cost
 
and
 
complexity
 
of
 
correction
 
are
 
much
 
higher.
 ●  Enhanced  Test  Coverage:  By  examining  multiple  layers  of  the  system,  including  schemas,  
constraints,
 
triggers,
 
stored
 
procedures,
 
and
 
data
 
flows,
 
database
 
testing
 
improves
 
the
 
overall
 
coverage
 
of
 
tests.
 
This
 
ensures
 
that
 
both
 
functionality
 
and
 
data
 
structure
 
are
 
thoroughly
 
assessed,
 
enhancing
 
the
 
reliability
 
and
 
stability
 
of
 
the
 
software
 
application.
 ●  Data  Protection:  One  of  the  key  benefits  of  database  testing  is  its  role  in  safeguarding  user  
data.
 
By
 
simulating
 
and
 
checking
 
scenarios
 
that
 
could
 
lead
 
to
 
unauthorized
 
access
 
or
 
data
 
--- Page 6 ---
leakage,  developers  can  identify  vulnerabilities  in  advance  and  implement  appropriate  
preventative
 
measures.
 ●  Ensures  Quality  and  Security:  Regular  testing  contributes  to  both  software  quality  and  
security.
 
By
 
verifying
 
data
 
integrity,
 
transaction
 
handling,
 
and
 
consistency,
 
the
 
system
 
can
 
operate
 
smoothly
 
while
 
minimizing
 
potential
 
vulnerabilities
 
that
 
could
 
be
 
exploited.
 ●  Data  Durability:  Database  testing  helps  ensure  long-term  durability  of  data.  Through  regular  
validation
 
of
 
data
 
integrity,
 
accuracy,
 
and
 
uniformity,
 
the
 
system
 
maintains
 
consistent
 
and
 
reliable
 
performance
 
over
 
the
 
entire
 
lifecycle
 
of
 
the
 
application.
 ●  Prevents  Issues:  Testing  helps  prevent  critical  problems  such  as  deadlocks,  data  corruption,  
or
 
even
 
security
 
breaches.
 
By
 
proactively
 
detecting
 
and
 
addressing
 
potential
 
risks,
 
the
 
system
 
can
 
maintain
 
smooth
 
and
 
safe
 
operations,
 
reducing
 
the
 
likelihood
 
of
 
operational
 
failures.
 
b.  Disadvantages  
●  Manual  Complexity:  Manual  database  testing  can  become  extremely  intricate,  particularly  as  
the
 
volume
 
of
 
data
 
grows
 
and
 
the
 
database
 
structures
 
become
 
more
 
complex.
 
Testers
 
must
 
carefully
 
examine
 
numerous
 
tables,
 
relationships,
 
constraints,
 
and
 
transactions,
 
which
 
is
 
time-consuming
 
and
 
increases
 
the
 
likelihood
 
of
 
human
 
error.
 
The
 
more
 
complex
 
the
 
database,
 
the
 
greater
 
the
 
challenge
 
in
 
ensuring
 
complete
 
coverage
 
through
 
manual
 
testing.
 ●  Automation  Cost:  Although  automation  can  significantly  improve  efficiency  and  
consistency,
 
implementing
 
automated
 
testing
 
tools
 
often
 
comes
 
with
 
substantial
 
costs.
 
These
 
costs
 
may
 
include
 
purchasing
 
software
 
licenses,
 
training
 
staff
 
to
 
use
 
the
 
tools
 
effectively,
 
and
 
maintaining
 
automated
 
test
 
scripts.
 
For
 
large-scale
 
projects,
 
these
 
expenses
 
can
 
become
 
a
 
significant
 
portion
 
of
 
the
 
project
 
budget.
 ●  Skill  Requirement:  Effective  database  testing  requires  testers  to  have  a  deep  understanding  
of
 
database
 
design,
 
SQL
 
queries,
 
stored
 
procedures,
 
triggers,
 
and
 
the
 
specific
 
data
 
requirements
 
of
 
the
 
application.
 
Without
 
sufficient
 
expertise,
 
testers
 
may
 
overlook
 
critical
 
defects,
 
misinterpret
 
results,
 
or
 
fail
 
to
 
design
 
comprehensive
 
test
 
cases,
 
which
 
compromises
 
the
 
effectiveness
 
of
 
testing.
 ●  Maintenance  Overhead:  Databases  are  frequently  subject  to  changes  such  as  schema  
modifications,
 
addition
 
of
 
new
 
tables,
 
updates
 
to
 
stored
 
procedures,
 
or
 
changes
 
in
 
data
 
logic.
 
Each
 
of
 
these
 
changes
 
necessitates
 
updates
 
to
 
the
 
test
 
plan
 
and
 
test
 
scripts
 
to
 
ensure
 
continued
 
accuracy.
 
This
 
creates
 
ongoing
 
maintenance
 
overhead
 
and
 
requires
 
testers
 
to
 
stay
 
vigilant
 
to
 
keep
 
tests
 
aligned
 
with
 
the
 
evolving
 
database
 
structure.
 ●  Scoping  Challenges:  Determining  the  critical  areas  that  need  testing  within  large  and  
complex
 
databases
 
can
 
be
 
difficult.
 
Testers
 
must
 
prioritize
 
which
 
tables,
 
transactions,
 
and
 
workflows
 
are
 
most
 
important
 
to
 
test,
 
while
 
ensuring
 
sufficient
 
coverage
 
to
 
prevent
 
data
 
corruption,
 
inconsistencies,
 
or
 
security
 
vulnerabilities.
 
Misjudging
 
the
 
scope
 
can
 
result
 
in
 
untested
 
areas
 
and
 
potential
 
operational
 
risks.
 
II  -  Database  Testing  Process  1.  Stages  of  DB  Testing  A  standard  database  testing  process  follows  the  Software  Testing  Life  Cycle  (STLC)  principles.  1.  Requirement  Analysis:  Testers  study  business  requirements,  the  database  schema  (ERD),  
and
 
specifications
 
to
 
understand
 
data
 
flows,
 
business
 
rules,
 
and
 
constraints.
 
--- Page 7 ---
2.  Test  Planning:  This  stage  involves  defining  the  scope  of  testing,  objectives,  types  of  tests  to  
be
 
performed,
 
required
 
resources,
 
and
 
tools.
 3.  Test  Case  Design:  Detailed  test  cases  are  written.  This  is  a  crucial  phase  that  includes  
preparing
 
the
 
SQL
 
queries
 
needed
 
to
 
validate
 
the
 
data.
 4.  Test  Environment  Setup:  A  dedicated  database  environment,  closely  mirroring  the  
production
 
environment,
 
is
 
prepared.
 
This
 
is
 
a
 
critical
 
step
 
to
 
ensure
 
safety
 
and
 
accuracy.
 
Testing
 
is
 
never
 
done
 
on
 
the
 
live
 
Production
 
Database
.
 
Instead,
 
testing
 
occurs
 
in:
 ○  Local  Development  Database:  Used  by  individual  testers/developers  for  debugging  
and
 
initial
 
testing.
 ○  Populated  Development  Database:  A  shared  database  with  a  substantial  volume  of  
data
 
to
 
ensure
 
the
 
application
 
functions
 
with
 
a
 
large
 
data
 
load.
 ○  Deployment  Database:  A  staging  environment  where  final  tests  are  executed  before  
deployment
 
to
 
production.
 5.  Test  Execution:  The  designed  test  cases  are  run.  This  involves  performing  actions  in  the  
application
 
and
 
executing
 
SQL
 
queries
 
to
 
check
 
the
 
results.
 6.  Defect  Reporting  &  Closure:  All  defects  found  are  logged  with  clear  evidence.  After  a  
defect
 
is
 
fixed,
 
testers
 
re-test
 
the
 
functionality
 
and
 
perform
 
regression
 
testing
 
before
 
closing
 
the
 
defect.
 
2.  How  to  test  the  Database  Database  testing  can  be  performed  using  two  different  approaches.  Testers  should  be  aware  of  both  to  
select
 
the
 
most
 
suitable
 
one
 
as
 
per
 
their
 
project
 
requirements.
 
a.  Manual  Approach  
This  involves  the  execution  of  test  cases  and  SQL  queries  manually  by  testers  without  any  automation  
tools.
 ●  Advantages:  This  approach  gives  hands-on  data  inspection  and  is  appropriate  for  complex  
scenarios
 
and
 
exploratory
 
testing,
 
allowing
 
testers
 
to
 
easily
 
verify
 
data
 
integrity,
 
functionality,
 
and
 
quality.
 ●  General  Procedure:  1.  Launch  the  SQL  server  and  access  the  query  analyzer.  2.  Compose  commands  (SQL  queries)  to  retrieve  data.  3.  Measure  the  retrieved  data  against  the  anticipated  results  (Expected  Results).  4.  Perform  data  updates  or  deletions  to  evaluate  the  software  application's  performance  
and
 
response.
 
b.  Automation  Approach  
As  data  volumes  and  system  complexity  escalate,  manually  ensuring  comprehensive  coverage  
becomes
 
laborious.
 
The
 
test
 
automation
 
approach
 
uses
 
automated
 
testing
 
tools.
 ●  Advantages:  Reduces  repetitive  manual  tasks,  allowing  testers  to  focus  on  critical  aspects.  It  
is
 
highly
 
advantageous
 
for
 
regression
 
testing,
 
integrity
 
monitoring,
 
and
 
Agile
 
environments
 
with
 
frequent
 
releases.
 ●  Fundamental  Procedures:  
--- Page 8 ---
1.  Determine  Scope:  Define  the  key  areas  of  the  database  that  require  automation.  2.  Develop  Test  Scripts:  Create  automated  scripts  that  interact  with  the  database,  execute  
test
 
cases,
 
and
 
validate
 
the
 
outcomes.
 3.  Prioritize  Test  Cases:  Identify  critical  test  cases  that  require  automation  first.  4.  Execute  Tests:  Run  the  prepared  scripts  to  perform  testing  (data  retrieval,  validation,  
etc.).
 5.  Document  Outcomes:  Record  and  document  the  outcomes,  including  any  errors  
detected.
 6.  Monitor  Results:  Continuously  monitor  results  to  find  patterns  (e.g.,  performance  
degradation)
 
or
 
issues.
 7.  Validate  (Cross-Reference):  Cross-check  the  database  test  outcomes  with  the  UI  test  
report
 
for
 
consistency.
 
c.  Manual  vs.  Automated  Comparison  
Criteria  Manual  Testing  Automated  Testing  
Nature  Testers  manually  write  and  run  SQL  queries,  visually  inspecting  the  results.  
Uses  scripts  and  specialized  tools  to  execute  test  cases  and  compare  results.  
When  to  Use  
Best  for  exploratory  testing  and  complex,  hard-to-automate  scenarios.  
Best  for  regression  testing,  performance  testing,  and  tests  involving  large  datasets.  
Pros  Flexible,  no  expensive  tools  required,  can  find  unexpected  bugs.  
Fast,  repeatable,  reliable,  saves  time  in  the  long  run,  easily  simulates  large  loads.  
Cons  Time-consuming,  prone  to  human  error,  tedious,  difficult  with  large  data  volumes.  
High  initial  setup  cost,  requires  programming  skills,  scripts  need  maintenance  if  the  DB  changes.  
 3.  How  to  write  test  cases  Database  testing  is  a  form  of  grey  box  testing  since  it  necessitates  validating  both  the  backend  
(database)
 
and
 
the
 
user
 
interface
 
that
 
retrieves
 
data.
 
a.  Basic  Principles  
--- Page 9 ---
1.  Understand  Requirements:  First,  testers  must  understand  the  application's  business  rules  
and
 
prerequisites.
 2.  Gather  Information:  Collect  details  regarding  all  tables,  joins,  cursors,  triggers,  and  stored  
procedures,
 
including
 
their
 
input
 
and
 
output
 
parameters.
 3.  Write  Test  Cases:  Initiate  the  composition  of  test  cases  for  these  components,  ensuring  
coverage
 
of
 
all
 
possible
 
paths
 
with
 
various
 
input
 
values.
 
b.  Structure  of  a  Test  Case  
Based  on  industry  standards,  a  professional  test  case  (in  its  design  phase)  should  include:  ●  Tracking  Information:  ○  Test  Case  ID :  A  unique  identifier  (e.g.,  TC_DB_USER_001).  ●  Test  Description:  ○  Purpose/Objective :  A  brief  description  of  the  test's  goal.  ○  Procedures/Steps :  A  detailed,  step-by-step  list  of  actions  to  perform.  ○  Script :  The  specific  SQL  query  used  for  validation,  if  necessary.  ●  Parameters/Data:  ○  Input :  The  exact  data  used  for  the  test  (e.g.,  Username:  'testuser' ).  ●  Results:  ○  Expected  Result :  The  defined,  correct  outcome  (e.g.,  "Query  returns  1  row.  The  
Password
 
column
 
is
 
encrypted.").
 ○  Observed  Result :  The  actual  outcome  of  the  test   ( filled  in  during  test  execution ).  ●  Management  Information:  ○  Environment :  The  database  environment  where  the  test  was  run  (e.g.,  Local  Dev  DB ).  ○  Status :  Pass ,  Fail ,  Blocked ,  Skipped  ( filled  in  during  test  execution ).  ○  Notes/Comments :  Any  additional  observations  by  the  tester.  
c.  Example  Test  Case  Objectives  
A  good  database  test  suite  should  include  test  cases  that  cover  several  general  objectives.  Here  are  the  
main
 
groups:
 ●  Data  Integrity  and  Constraint  Validation:  ○  Validate  that  data  entered  via  the  application's  user  interface  is  stored  in  the  database  
upon
 
clicking
 
the
 
"Submit"
 
button.
 ○  Verify  that  key  constraints  are  enforced,  such  as  ensuring  that  Primary  Key  and  
Foreign
 
Key
 
columns
 
do
 
not
 
accept
 
NULL
 
values.
 ●  End-to-End  Functional  Flow  Validation:  ○  Ensure  the  end-to-end  data  flow  is  functional  within  the  system,  spanning  from  the  
front-end
 
to
 
the
 
back-end
 
and
 
vice-versa.
 ●  System  Health  and  Error  Checking:  ○  Authenticate  (by  scrutinizing  the  log  files)  for  the  absence  of  critical  database  issues,  
such
 
as
 
deadlocks
,
 
memory
 
failures
,
 
or
 
data
 
corruption
.
 ●  Structural  and  Metadata  Validation:  ○  Verify  the  retrievability  of  database-related  metadata,  such  as  the  database  name,  
device
 
details,
 
log
 
file
 
locations,
 
and
 
storage
 
space,
 
by
 
using
 
system
 
queries.
 
--- Page 10 ---
III  -  Types  of  Database  Testing  
This  section  outlines  the  three  primary  pillars  of  database  testing:  Structural,  Functional,  and  
Non-functional
 
testing.
 
Each
 
category
 
addresses
 
specific
 
layers
 
of
 
the
 
database
 
architecture,
 
ensuring
 
data
 
integrity,
 
operational
 
efficiency,
 
and
 
security.
 
1.  Structural  Testing  Structural  testing,  also  known  as  glass-box  testing  or  white-box  testing,  focuses  on  examining  the  
internal
 
structure
 
of
 
the
 
system
 
(which
 
is
 
the
 
database
 
and
 
its
 
components
 
in
 
this
 
case).
 
The
 
goal
 
is
 
to
 
ensure
 
that
 
the
 
database
 
schema,
 
tables,
 
relationships,
 
constraints,
 
and
 
other
 
structural
 
elements
 
are
 
designed
 
and
 
implemented
 
correctly.
  a.  Table  and  Column  Validation  Validating  tables  and  columns  is  a  fundamental  step  in  database  testing,  as  it  ensures  that  the  
implemented
 
database
 
structure
 
accurately
 
reflects
 
the
 
system’s
 
design
 
specifications.
 
This
 
process
 
focuses
 
on
 
confirming
 
the
 
correct
 
creation
 
of
 
tables,
 
the
 
presence
 
and
 
correctness
 
of
 
columns,
 
and
 
the
 
enforcement
 
of
 
critical
 
constraints
 
that
 
maintain
 
data
 
integrity.
 
The
 
key
 
activities
 
involved
 
in
 
this
 
validation
 
include
 
the
 
following:
 ●  Verifying  that  all  required  tables  have  been  created.  The  first  step  is  to  ensure  that  every  table  
defined
 
in
 
the
 
system
 
design
 
or
 
Entity
 
Relationship
 
Diagram
 
(ERD)
 
actually
 
exists
 
in
 
the
 
database.
 
Missing
 
tables
 
often
 
indicate
 
incomplete
 
implementation
 
or
 
misunderstandings
 
during
 
development.
 
By
 
cross-referencing
 
the
 
database
 
schema
 
with
 
the
 
original
 
design
 
documents,
 
testers
 
can
 
confirm
 
the
 
structural
 
completeness
 
of
 
the
 
database.
 ●  Checking  that  each  table  contains  the  expected  columns  with  correct  data  types.  Each  table  
should
 
include
 
all
 
the
 
columns
 
specified
 
in
 
the
 
design,
 
and
 
these
 
columns
 
must
 
use
 
the
 
correct
 
data
 
types.
 
For
 
example,
 
numerical
 
fields
 
should
 
be
 
defined
 
using
 
types
 
like
 
INT,
 
text-based
 
fields
 
should
 
use
 
VARCHAR,
 
and
 
date
 
fields
 
should
 
be
 
declared
 
as
 
DATE
 
or
 
similar.
 
Using
 
incorrect
 
data
 
types
 
can
 
cause
 
issues
 
such
 
as
 
data
 
truncation,
 
invalid
 
calculations,
 
or
 
errors
 
during
 
data
 
processing.
 
Validating
 
column
 
definitions
 
helps
 
guarantee
 
consistency
 
and
 
reliability.
 ●  Testing  that  essential  constraints  are  defined  correctly  (PRIMARY  KEY,  FOREIGN  KEY,  
NOT
 
NULL,
 
etc.).
 
Constraints
 
play
 
a
 
crucial
 
role
 
in
 
maintaining
 
data
 
accuracy
 
and
 
enforcing
 
business
 
rules.
 
During
 
testing,
 
it
 
is
 
important
 
to
 
verify
 
that
 
primary
 
keys
 
uniquely
 
identify
 
records,
 
foreign
 
keys
 
establish
 
proper
 
relationships
 
between
 
tables,
 
and
 
NOT
 
NULL
 
constraints
 
prevent
 
missing
 
values
 
in
 
required
 
fields.
 
If
 
these
 
constraints
 
are
 
not
 
implemented
 
correctly,
 
the
 
database
 
may
 
accept
 
invalid
 
or
 
inconsistent
 
data,
 
leading
 
to
 
logical
 
errors
 
across
 
the
 
application.
 ●  Ensuring  that  default  values  are  correctly  set.  Some  columns  are  designed  to  automatically  fill  
in
 
with
 
a
 
default
 
value
 
when
 
no
 
input
 
is
 
provided.
 
Testers
 
should
 
validate
 
that
 
these
 
default
 
values
 
are
 
applied
 
appropriately
 
and
 
match
 
the
 
expected
 
behavior.
 
Incorrect
 
or
 
missing
 
defaults
 
can
 
cause
 
unexpected
 
data
 
inconsistencies
 
or
 
force
 
unnecessary
 
manual
 
data
 
entry.
 ●  Validating  that  column  lengths  match  design  requirements.  For  character-based  fields  such  as  
VARCHAR,
 
the
 
maximum
 
length
 
must
 
align
 
with
 
the
 
requirements
 
defined
 
during
 
system
 
design.
 
Columns
 
that
 
are
 
too
 
short
 
may
 
lead
 
to
 
data
 
truncation,
 
while
 
excessively
 
large
 
fields
 
can
 
impact
 
storage
 
efficiency.
 
Testing
 
column
 
length
 
ensures
 
that
 
the
 
database
 
can
 
store
 
information
 
fully
 
and
 
appropriately.
 
--- Page 11 ---
●  Testing  naming  consistency  for  tables  and  columns.  Consistent  naming  conventions  
contribute
 
to
 
database
 
readability
 
and
 
long-term
 
maintainability.
 
Testers
 
should
 
check
 
whether
 
table
 
and
 
column
 
names
 
follow
 
the
 
chosen
 
style
 
guidelines—such
 
as
 
using
 
snake_case,
 
avoiding
 
spaces,
 
and
 
applying
 
clear
 
pluralization
 
rules.
 
Inconsistent
 
or
 
unclear
 
naming
 
may
 
cause
 
confusion
 
for
 
developers
 
and
 
complicate
 
future
 
maintenance.
 ●  Checking  for  unnecessary  duplicate  columns  across  tables.  The  database  should  not  contain  
duplicate
 
columns
 
across
 
multiple
 
tables
 
unless
 
this
 
duplication
 
is
 
explicitly
 
required
 
by
 
the
 
design.
 
Unintentional
 
duplication
 
often
 
leads
 
to
 
redundancy
 
and
 
increases
 
the
 
risk
 
of
 
inconsistent
 
data.
 
Reviewing
 
column
 
distribution
 
across
 
tables
 
helps
 
maintain
 
a
 
normalized
 
and
 
efficient
 
database
 
structure.
 ●  Validating  unique  constraints.  Finally,  testers  must  verify  that  columns  intended  to  store  
unique
 
values—such
 
as
 
user
 
emails,
 
usernames,
 
or
 
identification
 
numbers—are
 
correctly
 
configured
 
with
 
UNIQUE
 
constraints.
 
This
 
ensures
 
that
 
the
 
database
 
prevents
 
duplicate
 
entries
 
and
 
upholds
 
the
 
uniqueness
 
rules
 
essential
 
to
 
the
 
application’s
 
logic.
 
b.  Index  Testing  
Index  testing  evaluates  the  performance  optimization  structures  within  the  database.  An  index  is  a  
data
 
structure
 
in
 
the
 
database
 
that
 
makes
 
data
 
retrieval
 
faster—similar
 
to
 
the
 
index
 
of
 
a
 
book
 
that
 
helps
 
you
 
quickly
 
find
 
a
 
topic
 
without
 
reading
 
every
 
page.
 
The
 
most
 
common
 
data
 
structure
 
used
 
for
 
database
 
indexes
 
is
 
B-Tree
 
and
 
its
 
variants.
 
While
 
indexes
 
speed
 
up
 
SELECT
 
queries,
 
they
 
may
 
slow
 
down
 
INSERT,
 
UPDATE,
 
and
 
DELETE
 
operations
 
because
 
the
 
index
 
also
 
needs
 
to
 
be
 
updated.
 
The
 
key
 
activities
 
involved
 
in
 
index
 
testing
 
include
 
the
 
following:
 ●  Testing  queries  with  and  without  indexes  to  measure  performance  differences.  This  involves  
running
 
the
 
same
 
query
 
both
 
with
 
and
 
without
 
indexes
 
to
 
compare
 
execution
 
times
 
and
 
demonstrate
 
how
 
indexes
 
improve
 
query
 
speed
 
and
 
whether
 
they
 
are
 
actually
 
useful.
 
This
 
helps
 
determine
 
if
 
the
 
index
 
is
 
providing
 
meaningful
 
performance
 
benefits.
 ●  Verifying  that  indexes  are  correctly  defined  on  columns  used  in  WHERE  clauses.  Testers  
should
 
check
 
that
 
columns
 
frequently
 
used
 
in
 
filters
 
(WHERE
 
conditions)
 
have
 
indexes
 
to
 
speed
 
up
 
searches.
 
Without
 
proper
 
indexing,
 
the
 
database
 
may
 
need
 
to
 
scan
 
entire
 
tables,
 
which
 
significantly
 
degrades
 
performance
 
on
 
large
 
datasets.
 ●  Checking  the  impact  of  indexes  on  INSERT,  UPDATE,  and  DELETE  operations.  It  is  
essential
 
to
 
ensure
 
that
 
adding
 
indexes
 
does
 
not
 
make
 
write
 
operations
 
too
 
slow,
 
since
 
indexes
 
must
 
be
 
updated
 
when
 
data
 
changes.
 
An
 
excessive
 
number
 
of
 
indexes
 
can
 
cause
 
more
 
harm
 
than
 
good
 
by
 
slowing
 
down
 
data
 
modifications.
 ●  Validating  that  composite  indexes  are  correctly  defined  for  multi-column  queries.  Testers  
must
 
confirm
 
that
 
multi-column
 
indexes
 
match
 
queries
 
that
 
filter
 
by
 
more
 
than
 
one
 
column.
 
The
 
effectiveness
 
of
 
a
 
composite
 
index
 
depends
 
on
 
how
 
well
 
it
 
aligns
 
with
 
the
 
query
 
patterns
 
used
 
in
 
the
 
application.
 ●  Testing  the  behavior  of  queries  when  using  covered  indexes.  A  covered  index  contains  all  the  
columns
 
needed
 
by
 
a
 
query,
 
allowing
 
the
 
database
 
to
 
answer
 
the
 
query
 
using
 
only
 
the
 
index
 
without
 
reading
 
the
 
table.
 
Testers
 
should
 
check
 
whether
 
queries
 
can
 
be
 
answered
 
using
 
only
 
the
 
index,
 
which
 
improves
 
performance
 
significantly.
 ●  Verifying  that  the  order  of  columns  in  composite  indexes  is  optimal  for  query  performance.  
The
 
order
 
in
 
which
 
columns
 
are
 
arranged
 
in
 
a
 
composite
 
index
 
affects
 
its
 
efficiency.
 
Testers
 
should
 
ensure
 
that
 
the
 
most
 
selective
 
or
 
most
 
frequently
 
used
 
column
 
appears
 
first
 
in
 
the
 
index
 
for
 
better
 
performance.
 
--- Page 12 ---
●  Confirming  that  join  conditions  use  indexed  columns.  Joins  are  resource-intensive  operations,  
and
 
using
 
indexed
 
columns
 
in
 
join
 
conditions
 
ensures
 
that
 
joins
 
run
 
faster
 
and
 
avoid
 
full
 
table
 
scans.
 
Testers
 
should
 
verify
 
that
 
foreign
 
key
 
columns
 
and
 
other
 
join
 
columns
 
are
 
properly
 
indexed.
 ●  Validating  that  unnecessary  or  redundant  indexes  are  not  present.  Testers  must  make  sure  the  
database
 
doesn't
 
have
 
duplicate
 
or
 
unused
 
indexes,
 
which
 
only
 
slow
 
down
 
write
 
operations
 
and
 
waste
 
storage.
 
Regular
 
review
 
of
 
index
 
usage
 
helps
 
maintain
 
optimal
 
database
 
performance.
 
c.  Data  Migration  Testing  
Data  migration  testing  validates  the  process  of  moving  data  from  one  system  to  another—for  example,  
from
 
an
 
old
 
database
 
to
 
a
 
new
 
one,
 
or
 
from
 
one
 
server
 
to
 
another.
 
The
 
goal
 
is
 
to
 
ensure
 
all
 
data
 
is
 
transferred
 
accurately,
 
completely,
 
and
 
without
 
corruption.
 
The
 
key
 
activities
 
involved
 
in
 
data
 
migration
 
testing
 
include
 
the
 
following:.
 ●  Validating  that  data  types  and  values  are  consistent  after  migration.  Testers  should  check  
whether
 
the
 
migrated
 
data
 
keeps
 
the
 
same
 
data
 
types
 
(e.g.,
 
INT,
 
DATE,
 
VARCHAR)
 
and
 
that
 
values
 
were
 
not
 
changed,
 
lost,
 
or
 
truncated
 
during
 
the
 
transfer
 
process.
 
Any
 
mismatch
 
in
 
data
 
types
 
or
 
altered
 
values
 
indicates
 
a
 
migration
 
failure.
 ●  Testing  migration  of  both  structured  and  unstructured  data  (e.g.,  BLOBs,  CLOBs).  Migration  
testing
 
must
 
ensure
 
that
 
all
 
kinds
 
of
 
data—like
 
tables,
 
documents,
 
images,
 
or
 
large
 
text
 
fields—are
 
correctly
 
transferred
 
without
 
corruption.
 
Unstructured
 
data
 
often
 
requires
 
special
 
handling
 
to
 
prevent
 
data
 
loss
 
or
 
formatting
 
issues.
 ●  Checking  the  mapping  of  relationships  and  foreign  keys  between  tables  post-migration.  
Testers
 
must
 
verify
 
that
 
links
 
between
 
tables
 
(like
 
parent-child
 
relationships)
 
remain
 
valid
 
and
 
no
 
broken
 
references
 
occur.
 
Foreign
 
key
 
violations
 
after
 
migration
 
indicate
 
that
 
referential
 
integrity
 
was
 
not
 
maintained
 
during
 
the
 
transfer.
 ●  Validating  that  data  migration  doesn't  violate  unique  constraints  or  integrity  rules.  The  
migration
 
process
 
should
 
ensure
 
that
 
no
 
duplicate
 
records,
 
missing
 
values,
 
or
 
rule
 
violations
 
appear
 
in
 
the
 
new
 
system
 
after
 
migration.
 
Any
 
violation
 
of
 
database
 
constraints
 
suggests
 
that
 
the
 
migration
 
process
 
has
 
introduced
 
data
 
quality
 
issues.
 ●  Testing  migration  of  large  datasets  to  ensure  performance  and  data  integrity.  Testers  should  
confirm
 
that
 
the
 
migration
 
works
 
correctly
 
with
 
millions
 
of
 
rows,
 
completes
 
within
 
acceptable
 
time,
 
and
 
that
 
no
 
data
 
is
 
lost
 
or
 
duplicated
 
during
 
the
 
process.
 
Performance
 
testing
 
of
 
migration
 
operations
 
helps
 
identify
 
bottlenecks
 
and
 
optimize
 
the
 
transfer
 
process.
  
d.  Database  Server  Validation  
Database  server  validation  ensures  that  the  system  (software  and  hardware)  that  stores,  manages,  and  
processes
 
all
 
database
 
operations
 
is
 
functioning
 
correctly.
 
The
 
database
 
server
 
handles
 
queries,
 
connections,
 
security,
 
backups,
 
and
 
ensures
 
data
 
is
 
available
 
and
 
reliable
 
for
 
applications.
 
The
 
key
 
activities
 
involved
 
in
 
database
 
server
 
validation
 
include
 
the
 
following:
 ●  Testing  database  server  connectivity  and  ensuring  it's  accessible  from  the  application.  This  
involves
 
verifying
 
that
 
the
 
application
 
and
 
users
 
can
 
connect
 
to
 
the
 
server
 
without
 
errors.
 
Connection
 
failures
 
can
 
stem
 
from
 
network
 
issues,
 
incorrect
 
configuration,
 
or
 
firewall
 
restrictions.
 
--- Page 13 ---
●  Validating  that  the  database  server  is  configured  with  the  correct  authentication  and  
authorization
 
settings.
 
Testers
 
should
 
check
 
that
 
login
 
credentials,
 
roles,
 
and
 
permissions
 
are
 
correctly
 
configured
 
to
 
protect
 
the
 
database.
 
Improper
 
authentication
 
settings
 
can
 
lead
 
to
 
unauthorized
 
access
 
or
 
prevent
 
legitimate
 
users
 
from
 
accessing
 
necessary
 
resources.
 ●  Testing  database  server  performance  by  running  various  types  of  queries.  This  involves  
running
 
different
 
queries
 
to
 
confirm
 
the
 
server
 
responds
 
quickly
 
and
 
handles
 
operations
 
efficiently.
 
Performance
 
benchmarks
 
help
 
identify
 
whether
 
the
 
server
 
meets
 
expected
 
service
 
levels.
 ●  Checking  the  server's  response  to  high  loads  and  concurrent  connections.  Testers  should  
simulate
 
many
 
users
 
or
 
heavy
 
traffic
 
to
 
ensure
 
the
 
server
 
remains
 
stable
 
and
 
does
 
not
 
crash
 
or
 
slow
 
down
 
excessively.
 
Load
 
testing
 
helps
 
determine
 
the
 
server's
 
capacity
 
and
 
identify
 
breaking
 
points.
 ●  Validating  that  database  backups  and  recovery  processes  work  as  expected.  It  is  critical  to  
make
 
sure
 
the
 
database
 
can
 
be
 
backed
 
up
 
and
 
restored
 
correctly,
 
ensuring
 
no
 
data
 
loss
 
during
 
failures.
 
Regular
 
testing
 
of
 
backup
 
and
 
recovery
 
procedures
 
prevents
 
catastrophic
 
data
 
loss
 
in
 
real
 
disaster
 
scenarios.
 ●  Testing  database  server  failover  and  redundancy  mechanisms.  If  using  replication  or  
clustering,
 
testers
 
must
 
verify
 
that
 
the
 
database
 
automatically
 
switches
 
to
 
a
 
standby
 
server
 
when
 
the
 
main
 
server
 
fails.
 
Failover
 
testing
 
ensures
 
high
 
availability
 
and
 
business
 
continuity.
 ●  Checking  for  server  logs  to  identify  errors,  warnings,  and  performance  bottlenecks.  
Reviewing
 
logs
 
helps
 
identify
 
performance
 
issues,
 
failed
 
queries,
 
security
 
violations,
 
or
 
system
 
problems.
 
Log
 
analysis
 
is
 
essential
 
for
 
proactive
 
monitoring
 
and
 
troubleshooting.
 ●  Testing  compatibility  of  the  database  server  with  the  operating  system  and  other  software  
components.
 
Testers
 
should
 
ensure
 
the
 
database
 
server
 
works
 
properly
 
with
 
the
 
operating
 
system,
 
drivers,
 
libraries,
 
and
 
application
 
software.
 
Incompatibility
 
issues
 
can
 
cause
 
crashes,
 
data
 
corruption,
 
or
 
degraded
 
performance.
  2.  Functional  Testing  For  database  testing  specifically,  functional  testing  focuses  more  on  the  functional  aspects  of  the  
database,
 
ensuring
 
that
 
it
 
can
 
perform
 
its
 
intended
 
purposes.
  
a.  Data  Retrieval  Testing  
Data  retrieval  testing  validates  the  database's  ability  to  correctly  fetch  and  return  data  based  on  various  
query
 
conditions.
 
This
 
ensures
 
that
 
SELECT
 
operations
 
function
 
as
 
expected
 
across
 
different
 
scenarios.
 
The
 
key
 
activities
 
involved
 
in
 
data
 
retrieval
 
testing
 
include
 
the
 
following:
 ●  Testing  a  basic  SELECT  query  to  retrieve  all  rows  from  a  table.  This  fundamental  test  verifies  
that
 
all
 
rows
 
and
 
columns
 
can
 
be
 
retrieved
 
correctly
 
from
 
a
 
table
 
without
 
any
 
filtering
 
or
 
conditions.
 
It
 
confirms
 
that
 
the
 
database
 
can
 
perform
 
simple
 
data
 
retrieval
 
operations.
 ●  Testing  a  SELECT  query  with  a  WHERE  clause  to  retrieve  specific  rows  based  on  a  
condition.
 
Testers
 
should
 
check
 
that
 
filtering
 
conditions
 
return
 
only
 
the
 
intended
 
rows,
 
ensuring
 
that
 
the
 
query
 
logic
 
correctly
 
interprets
 
comparison
 
operators
 
and
 
boolean
 
conditions.
 ●  Testing  a  SELECT  query  with  a  JOIN  to  retrieve  data  from  related  tables.  This  ensures  that  
data
 
from
 
related
 
tables
 
is
 
combined
 
correctly
 
using
 
foreign
 
key
 
relationships.
 
JOIN
 
--- Page 14 ---
operations  are  fundamental  to  relational  databases,  and  errors  in  joins  can  lead  to  missing  or  
duplicated
 
data.
 ●  Testing  a  SELECT  query  with  GROUP  BY  and  HAVING  clauses  to  retrieve  aggregated  data.  
Testers
 
must
 
validate
 
that
 
aggregation
 
functions
 
(SUM,
 
COUNT,
 
AVG,
 
etc.)
 
group
 
data
 
correctly
 
and
 
that
 
HAVING
 
filters
 
aggregated
 
results
 
properly.
 
Aggregation
 
queries
 
are
 
essential
 
for
 
reporting
 
and
 
analytics.
 ●  Testing  a  SELECT  query  with  LIMIT  or  TOP  to  retrieve  a  limited  number  of  rows.  This  
checks
 
that
 
queries
 
correctly
 
return
 
a
 
limited
 
number
 
of
 
rows
 
when
 
required,
 
which
 
is
 
useful
 
for
 
pagination
 
or
 
sampling
 
data.
 
Incorrect
 
limit
 
clauses
 
can
 
result
 
in
 
incomplete
 
data
 
sets
 
or
 
performance
 
issues.
  
b.  Data  Manipulation  Testing  
Data  manipulation  testing  ensures  that  INSERT,  UPDATE,  and  DELETE  operations  correctly  modify  
the
 
database
 
while
 
maintaining
 
data
 
integrity.
 
These
 
operations
 
are
 
fundamental
 
to
 
any
 
database
 
application.
 
The
 
key
 
activities
 
involved
 
in
 
data
 
manipulation
 
testing
 
include
 
the
 
following:
 ●  Testing  an  INSERT  statement  to  add  a  new  record  to  a  table.  Testers  should  verify  that  new  
records
 
are
 
correctly
 
added
 
to
 
a
 
table
 
with
 
all
 
required
 
fields
 
and
 
valid
 
data.
 
Failed
 
inserts
 
or
 
partial
 
data
 
entry
 
indicates
 
problems
 
with
 
constraints
 
or
 
data
 
validation.
 ●  Testing  an  UPDATE  statement  to  modify  existing  data  in  a  table.  This  involves  checking  that  
existing
 
data
 
can
 
be
 
modified
 
correctly
 
and
 
only
 
the
 
intended
 
rows
 
are
 
affected.
 
Poorly
 
constructed
 
UPDATE
 
statements
 
can
 
inadvertently
 
modify
 
more
 
rows
 
than
 
intended,
 
causing
 
data
 
corruption.
 ●  Testing  a  DELETE  statement  to  remove  a  specific  record  from  a  table.  Testers  must  ensure  
that
 
specific
 
records
 
can
 
be
 
removed
 
from
 
the
 
table
 
without
 
affecting
 
unrelated
 
data.
 
DELETE
 
operations
 
without
 
proper
 
WHERE
 
clauses
 
can
 
accidentally
 
remove
 
all
 
data
 
from
 
a
 
table.
 ●  Testing  combining  INSERT,  UPDATE,  and  DELETE  operations  within  a  single  transaction.  
This
 
verifies
 
that
 
multiple
 
operations
 
within
 
one
 
transaction
 
behave
 
as
 
a
 
unit—either
 
all
 
succeed
 
or
 
all
 
rollback
 
on
 
failure.
 
Transaction
 
integrity
 
is
 
critical
 
for
 
maintaining
 
consistent
 
database
 
states.
 ●  Testing  data  manipulation  within  a  stored  procedure  or  function.  Testers  should  check  that  
procedures
 
or
 
functions
 
correctly
 
insert,
 
update,
 
or
 
delete
 
data
 
as
 
intended,
 
and
 
maintain
 
consistency.
 
Stored
 
procedures
 
often
 
encapsulate
 
complex
 
business
 
logic
 
that
 
must
 
be
 
thoroughly
 
tested.
  
c.  Transaction  Testing  
Transaction  testing  validates  that  sequences  of  database  operations  are  treated  as  single  units  of  work,  
ensuring
 
the
 
ACID
 
properties
 
(Atomicity,
 
Consistency,
 
Isolation,
 
Durability)
 
are
 
maintained.
 
These
 
ACID
 
properties
 
guarantee
 
reliable
 
transaction
 
processing:
 
 ●  Atomicity  ensures  that  all  steps  in  a  transaction  either  fully  complete  or  are  entirely  rolled  
back.
 ●  Consistency  ensures  the  database  transitions  from  one  valid  state  to  another  and  all  
rules/constraints
 
remain
 
satisfied.
 ●  Isolation  ensures  that  concurrent  transactions  do  not  interfere  with  each  other  and  produce  the  
same
 
result
 
as
 
if
 
executed
 
sequentially.
 
--- Page 15 ---
●  Durability  guarantees  that  once  a  transaction  is  committed,  its  changes  persist  even  in  cases  of  
crashes
 
or
 
system
 
failures.
 A  transaction  is  a  sequence  of  database  operations  that  must  be  treated  as  one  complete  unit—either  
all
 
operations
 
succeed
 
and
 
are
 
committed,
 
or
 
any
 
failure
 
causes
 
all
 
changes
 
to
 
be
 
rolled
 
back.
 
The
 
key
 
activities
 
involved
 
in
 
transaction
 
testing
 
include
 
the
 
following::
 ●  Testing  a  transaction  that  performs  multiple  INSERTs  and  ensures  all  are  committed.  Testers  
should
 
check
 
that
 
if
 
all
 
INSERTs
 
succeed,
 
the
 
transaction
 
is
 
committed
 
and
 
all
 
new
 
records
 
appear
 
in
 
the
 
database.
 
This
 
validates
 
the
 
atomicity
 
property
 
of
 
transactions.
 ●  Testing  a  transaction  that  updates  data  in  one  table  and  inserts  into  another,  verifying  both  are  
committed
 
or
 
rolled
 
back.
 
This
 
ensures
 
that
 
mixed
 
operations
 
across
 
multiple
 
tables
 
behave
 
as
 
a
 
single
 
unit—either
 
both
 
succeed
 
or
 
both
 
roll
 
back,
 
maintaining
 
consistency
 
across
 
related
 
data.
 ●  Testing  a  transaction  that  involves  multiple  database  operations,  including  SELECT,  
UPDATE,
 
and
 
DELETE.
 
Testers
 
must
 
ensure
 
that
 
more
 
complex
 
sequences
 
still
 
maintain
 
consistency,
 
and
 
all
 
operations
 
run
 
together
 
as
 
expected
 
without
 
partial
 
completion.
 ●  Testing  a  transaction  that  is  deliberately  designed  to  violate  a  unique  constraint,  ensuring  
proper
 
rollback.
 
By
 
deliberately
 
causing
 
an
 
error
 
(e.g.,
 
inserting
 
a
 
duplicate
 
value),
 
testers
 
can
 
confirm
 
that
 
the
 
entire
 
transaction
 
rolls
 
back
 
and
 
no
 
partial
 
changes
 
are
 
saved,
 
validating
 
the
 
rollback
 
mechanism.
 ●  Testing  a  transaction  that  is  rolled  back  due  to  an  error  in  the  middle  of  its  execution.  
Simulating
 
an
 
error
 
halfway
 
through
 
the
 
transaction
 
verifies
 
that
 
rollback
 
works
 
correctly
 
and
 
the
 
database
 
returns
 
to
 
its
 
original
 
state,
 
ensuring
 
data
 
integrity
 
is
 
preserved
 
even
 
when
 
operations
 
fail.
  
d.  Stored  Procedures  and  Function  Testing  
Stored  procedures  and  function  testing  validates  that  reusable  SQL  code  blocks  execute  correctly  and  
efficiently.
 
A
 
stored
 
procedure
 
is
 
prepared
 
SQL
 
code
 
that
 
can
 
be
 
saved
 
and
 
reused
 
repeatedly,
 
often
 
accepting
 
parameters
 
to
 
perform
 
different
 
actions
 
based
 
on
 
input
 
values.
 
A
 
function
 
is
 
similar
 
but
 
must
 
return
 
a
 
value
 
and
 
is
 
typically
 
used
 
for
 
calculations
 
or
 
transformations.
 
The
 
key
 
activities
 
involved
 
in
 
stored
 
procedures
 
and
 
function
 
testing
 
include
 
the
 
following:
 ●  Testing  stored  procedures  with  various  input  parameters  to  ensure  they  produce  expected  
results.
 
Testers
 
should
 
check
 
that
 
the
 
procedure
 
behaves
 
correctly
 
for
 
valid,
 
invalid,
 
and
 
boundary
 
inputs
 
and
 
produces
 
the
 
expected
 
output.
 
Parameter
 
validation
 
is
 
critical
 
to
 
prevent
 
unexpected
 
behavior.
 ●  Validating  that  stored  procedures  handle  exceptions  and  error  conditions  gracefully.  The  
procedure
 
should
 
be
 
able
 
to
 
handle
 
errors
 
safely
 
(like
 
invalid
 
inputs
 
or
 
constraint
 
violations)
 
without
 
crashing
 
or
 
corrupting
 
data.
 
Proper
 
error
 
handling
 
ensures
 
system
 
stability
 
and
 
data
 
integrity.
 ●  Testing  for  proper  authentication  and  authorization  checks  within  stored  procedures.  Testers  
must
 
verify
 
that
 
only
 
the
 
correct
 
user
 
roles
 
can
 
execute
 
sensitive
 
stored
 
procedures,
 
preventing
 
unauthorized
 
access.
 
Security
 
testing
 
of
 
procedures
 
helps
 
protect
 
sensitive
 
operations.
 ●  Verifying  that  triggers  are  correctly  fired  based  on  defined  conditions.  Database  triggers  
should
 
run
 
automatically
 
when
 
expected—for
 
example,
 
after
 
an
 
INSERT
 
or
 
UPDATE—and
 
perform
 
the
 
correct
 
action.
 
Trigger
 
testing
 
ensures
 
that
 
automated
 
database
 
behaviors
 
work
 
as
 
designed.
 
--- Page 16 ---
●  Testing  nested  or  recursive  stored  procedures  to  ensure  proper  execution.  Testers  should  check  
that
 
procedures
 
calling
 
other
 
procedures
 
run
 
in
 
the
 
correct
 
order
 
and
 
do
 
not
 
cause
 
infinite
 
loops
 
or
 
unexpected
 
behavior.
 
Complex
 
procedure
 
hierarchies
 
require
 
careful
 
testing.
 ●  Validating  that  functions  return  accurate  and  expected  results  for  different  input  values.  This  
ensures
 
that
 
SQL
 
functions
 
return
 
the
 
correct
 
output
 
for
 
different
 
types
 
of
 
inputs,
 
including
 
edge
 
cases
 
and
 
NULL
 
values.
 
Function
 
accuracy
 
is
 
essential
 
for
 
calculations
 
and
 
data
 
transformations.
 ●  Testing  stored  procedures  that  involve  multiple  tables  or  complex  data  manipulations.  Testers  
must
 
verify
 
that
 
procedures
 
that
 
modify
 
multiple
 
tables
 
produce
 
correct
 
results,
 
update
 
all
 
related
 
data
 
properly,
 
and
 
maintain
 
relationships.
 
Complex
 
procedures
 
are
 
prone
 
to
 
logic
 
errors.
 ●  Checking  the  impact  of  stored  procedures  on  data  consistency  and  ACID  properties.  This  
ensures
 
stored
 
procedures
 
maintain
 
Atomicity,
 
Consistency,
 
Isolation,
 
and
 
Durability—meaning
 
no
 
partial
 
updates,
 
no
 
data
 
corruption,
 
and
 
proper
 
transaction
 
behavior.
  3.  Non-functional  Testing  In  the  scope  of  this  type,  we  focus  on  performance  testing,  load  testing,  stress  testing,  security  testing,  
and
 
any
 
type
 
of
 
testing
 
whose
 
scope
 
goes
 
beyond
 
the
 
core
 
functionalities,
 
ensuring
 
that
 
these
 
non-functional
 
aspects
 
of
 
the
 
database
 
meet
 
the
 
business
 
requirements.
  
a.  Performance  Testing  
Performance  testing  evaluates  the  database's  response  time,  throughput,  and  resource  utilization  under  
different
 
load
 
conditions.
 
The
 
goal
 
is
 
to
 
ensure
 
that
 
the
 
database
 
meets
 
performance
 
requirements
 
and
 
provides
 
acceptable
 
response
 
times
 
for
 
users.
 
The
 
key
 
activities
 
involved
 
in
 
performance
 
testing
 
include
 
the
 
following:
 ●  Executing  a  complex  query  and  measuring  the  response  time,  comparing  it  with  a  response  
time
 
standard.
 
Testers
 
should
 
run
 
queries
 
that
 
involve
 
multiple
 
joins,
 
subqueries,
 
or
 
aggregations
 
and
 
verify
 
that
 
execution
 
times
 
fall
 
within
 
acceptable
 
limits.
 
Slow
 
query
 
performance
 
can
 
significantly
 
impact
 
user
 
experience.
 ●  Ensuring  the  response  time  remains  within  acceptable  limits  for  all  defined  user  loads.  
Performance
 
testing
 
should
 
validate
 
that
 
the
 
database
 
maintains
 
consistent
 
response
 
times
 
even
 
as
 
the
 
number
 
of
 
users
 
or
 
transactions
 
increases.
 
Degraded
 
performance
 
under
 
normal
 
loads
 
indicates
 
optimization
 
needs.
  
b.  Load  Testing  
Load  testing  assesses  the  database's  performance  and  responsiveness  under  expected  user  load.  It  is  a  
more
 
specific
 
type
 
of
 
performance
 
testing,
 
and
 
the
 
goal
 
is
 
to
 
simulate
 
real-life
 
usage
 
as
 
closely
 
as
 
possible.
 
The
 
key
 
activities
 
involved
 
in
 
load
 
testing
 
include
 
the
 
following:
 ●  Gradually  increasing  the  number  of  concurrent  users  accessing  the  database  and  observing  
how
 
the
 
database
 
handles
 
the
 
increased
 
load.
 
Testers
 
should
 
monitor
 
whether
 
performance
 
degrades
 
as
 
more
 
users
 
connect
 
simultaneously.
 
This
 
helps
 
identify
 
the
 
point
 
at
 
which
 
performance
 
becomes
 
unacceptable.
 ●  Loading  the  database  with  a  large  dataset  similar  to  expected  production  volumes.  Testing  
with
 
realistic
 
data
 
volumes
 
ensures
 
that
 
performance
 
measurements
 
reflect
 
actual
 
production
 
--- Page 17 ---
conditions.  Databases  often  behave  differently  with  small  test  datasets  versus  large  production  
datasets.
  
c.  Stress  Testing  
Stress  testing  assesses  the  database's  performance  under  extreme  load.  It  is  essentially  load  testing  put  
to
 
the
 
extreme,
 
where
 
the
 
database
 
is
 
subjected
 
to
 
unusually
 
large
 
amounts
 
of
 
users
 
and/or
 
extended
 
periods
 
to
 
identify
 
performance
 
issues
 
and
 
breaking
 
points.
 
The
 
key
 
activities
 
involved
 
in
 
stress
 
testing
 
include
 
the
 
following:
 ●  Applying  a  load  that  exceeds  the  expected  maximum  user  load.  Testers  should  push  the  
database
 
beyond
 
normal
 
capacity
 
to
 
identify
 
how
 
it
 
fails
 
and
 
whether
 
it
 
can
 
recover
 
gracefully.
 
Understanding
 
failure
 
modes
 
helps
 
plan
 
for
 
capacity
 
and
 
implement
 
proper
 
safeguards.
  
d.  Security  Testing  
Security  testing  identifies  vulnerabilities  of  the  database,  ensuring  that  it  is  protected  against  
unauthorized
 
access,
 
data
 
breaches,
 
and
 
security
 
risks.
 
Many
 
databases
 
implement
 
role-based
 
access
 
control
 
mechanisms
 
to
 
safeguard
 
the
 
system,
 
and
 
testers
 
need
 
to
 
verify
 
that
 
only
 
users
 
with
 
certain
 
roles
 
can
 
access
 
and
 
perform
 
certain
 
activities
 
in
 
the
 
database.
 
The
 
key
 
activities
 
involved
 
in
 
security
 
testing
 
include
 
the
 
following:
 ●  Attempting  to  access  the  database  with  incorrect  credentials.  Testers  should  verify  that  
unauthorized
 
access
 
attempts
 
are
 
denied
 
and
 
appropriate
 
error
 
messages
 
are
 
displayed.
 
This
 
confirms
 
that
 
authentication
 
mechanisms
 
are
 
functioning
 
correctly.
 ●  Validating  that  sensitive  data,  such  as  passwords  or  personal  information,  is  properly  
encrypted
 
in
 
the
 
database.
 
Testers
 
should
 
verify
 
that
 
data
 
at
 
rest
 
is
 
encrypted
 
and
 
that
 
decrypted
 
data
 
is
 
displayed
 
correctly
 
when
 
accessed
 
by
 
authorized
 
users.
 
Encryption
 
protects
 
sensitive
 
information
 
from
 
unauthorized
 
access.
 ●  Attempting  SQL  injection  attacks  by  inputting  malicious  code  into  queries  to  see  how  the  
system
 
responds.
 
This
 
tests
 
whether
 
the
 
application
 
properly
 
sanitizes
 
user
 
input
 
and
 
prevents
 
malicious
 
SQL
 
code
 
from
 
being
 
executed.
 
SQL
 
injection
 
is
 
one
 
of
 
the
 
most
 
common
 
and
 
dangerous
 
database
 
vulnerabilities.
 
 IV  -  Database  Testing  Tools  
This  section  provides  an  overview  of  key  tools  commonly  used  in  database  testing,  including  DBUnit  
for
 
test
 
execution,
 
Maven
 
for
 
build
 
automation,
 
and
 
Mockaroo
 
for
 
test
 
data
 
generation.
 
It
 
also
 
outlines
 
a
 
practical
 
demonstration
 
and
 
discusses
 
best
 
practices
 
for
 
applying
 
these
 
tools
 
effectively.
 
1.  Core  Testing  Tools  
a.  DBUnit  
Overview  
--- Page 18 ---
DBUnit  is  a  popular  JUnit  extension  designed  specifically  for  database-driven  projects.  Its  primary  
function
 
is
 
to
 
initialize
 
a
 
database
 
into
 
a
 
known,
 
controlled
 
state
 
before
 
each
 
test
 
runs.
 
This
 
ensures
 
that
 
test
 
results
 
are
 
consistent,
 
repeatable,
 
and
 
not
 
influenced
 
by
 
the
 
outcomes
 
of
 
previous
 
tests.
 
By
 
managing
 
the
 
database
 
state,
 
DBUnit
 
helps
 
isolate
 
tests
 
and
 
improves
 
the
 
reliability
 
of
 
the
 
entire
 
testing
 
process.
 
Key  Features  
DBUnit  offers  several  core  features  that  make  it  a  powerful  tool  for  automated  database  testing:  
●  Dataset  Import/Export: It  can  load  data  into  the  database  from  external  datasets  and  export  
database
 
content.
 
Supported
 
formats
 
include
 
XML,
 
CSV,
 
and
 
Excel,
 
providing
 
flexibility
 
in
 
how
 
test
 
data
 
is
 
managed. ●  Database  Independence: DBUnit  is  designed  to  work  with  a  wide  variety  of  database  
systems,
 
making
 
it
 
adaptable
 
to
 
different
 
project
 
environments. ●  Database  Assertions: It  provides  mechanisms  to  automatically  compare  the  actual  state  of  
the
 
database
 
after
 
a
 
test
 
with
 
an
 
expected
 
dataset,
 
simplifying
 
the
 
verification
 
process. ●  Setup  and  Teardown: DBUnit  can  automatically  set  up  the  database  state  before  a  test  
begins
 
(e.g.,
 
by
 
cleaning
 
tables
 
and
 
inserting
 
data)
 
and
 
tear
 
it
 
down
 
afterward,
 
ensuring
 
a
 
clean
 
slate
 
for
 
each
 
test
 
case. 
Architecture  
DBUnit  acts  as  an  intermediary  layer  that  connects  the  testing  framework  (like  JUnit),  the  test  
datasets,
 
and
 
the
 
database
 
itself.
 
During
 
a
 
test
 
run,
 
it
 
uses
 
a
 
database
 
connection
 
to
 
execute
 
operations
 
defined
 
in
 
the
 
dataset,
 
such
 
as
 
inserting,
 
updating,
 
or
 
deleting
 
records.
 
After
 
the
 
test
 
logic
 
is
 
executed,
 
it
 
can
 
then
 
be
 
used
 
to
 
assert
 
that
 
the
 
database
 
state
 
matches
 
the
 
expected
 
outcome.
 
b.  Maven  
Overview  
Maven  is  a  powerful  build  automation  and  project  management  tool.  It  simplifies  the  process  of  
building,
 
testing,
 
and
 
deploying
 
software
 
by
 
standardizing
 
the
 
project
 
structure
 
and
 
managing
 
dependencies.
 
In
 
the
 
context
 
of
 
database
 
testing,
 
Maven
 
plays
 
a
 
crucial
 
role
 
in
 
orchestrating
 
the
 
test
 
execution
 
environment.
 
Role  in  Database  Testing  
●  Dependency  Management: Maven  automatically  downloads  and  manages  all  required  
libraries,
 
including
 
DBUnit,
 
the
 
database
 
driver,
 
and
 
the
 
testing
 
framework
 
(JUnit).
 
This
 
is
 
handled
 
through
 
declarations
 
in
 
the
 pom.xml file. ●  Standardized  Project  Structure: Maven  enforces  a  standard  directory  layout,  which  
separates
 
application
 
source
 
code
 
(src/main/java)  from  test  code  (src/test/java).  This  keeps  the  
codebase
 
organized
 
and
 
maintainable. ●  Integration  with  the  Build  Lifecycle: Maven's  build  lifecycle  consists  of  distinct  phases  
(e.g.,
 validate,  compile,  test,  package).  The  test phase  is  where  unit  tests,  including  those  
written
 
with
 
DBUnit,
 
are
 
automatically
 
executed.
 
This
 
integration
 
ensures
 
that
 
database
 
tests
 
are
 
run
 
consistently
 
as
 
part
 
of
 
every
 
build. 
--- Page 19 ---
2.  Test  Data  Generation  
a.  The  Need  for  Data  Generation  Tools  
Manually  creating  test  data  is  often  a  significant  bottleneck  in  database  testing.  It  can  be  slow,  tedious,  
and
 
difficult
 
to
 
create
 
data
 
that
 
is
 
both
 
realistic
 
and
 
comprehensive.
 
Test
 
data
 
generation
 
tools
 
address
 
this
 
challenge
 
by
 
automating
 
the
 
creation
 
of
 
large,
 
high-quality
 
datasets.
 
These
 
tools
 
are
 
essential
 
when
 
we
 
need:
 
●  Large  volumes  of  data  to  simulate  production  environments  for  performance  testing. ●  Data  that  maintains  referential  integrity  (e.g.,  ensuring  every  order record  has  a  valid  customer_id). ●  Data  that  follows  realistic  patterns  and  distributions. 
b.  Mockaroo  
Overview  
Mockaroo  is  a  flexible,  web-based  tool  for  generating  realistic  test  data.  It  allows  users  to  design  a  
schema
 
with
 
various
 
data
 
types
 
and
 
constraints
 
and
 
then
 
export
 
the
 
generated
 
data
 
in
 
multiple
 
formats.
 
Key  Features  
●  No  Installation  Required: As  a  web-based  tool,  it  is  easily  accessible  without  any  local  
setup. ●  Customizable  Schemas: Users  can  define  columns,  choose  from  over  100  different  data  
types
 
(names,
 
emails,
 
countries,
 
etc.),
 
and
 
apply
 
custom
 
logic. ●  Multiple  Export  Formats: It  supports  exporting  data  as  CSV,  XML,  JSON,  and  SQL  INSERT statements,  making  it  highly  compatible  with  tools  like  DBUnit. ●  Free  Tier: It  offers  a  generous  free  tier  for  generating  up  to  1,000  rows  per  file. 
3.  Demonstration  Workflow:  Mockaroo  +  DBUnit  +  Maven  
A  typical  automated  database  testing  workflow  combines  these  tools  to  achieve  a  seamless  process:  
1.  Design  and  Generate  Dataset: Use  Mockaroo  to  design  a  schema  that  matches  the  target  
database
 
tables.
 
Generate
 
a
 
realistic
 
dataset
 
and
 
export
 
it
 
in
 
a
 
DBUnit-compatible
 
format,
 
such
 
as
 
CSV
 
or
 
XML. 2.  Load  Dataset  with  DBUnit: In  the  setup  phase  of  a  JUnit  test,  configure  DBUnit  to  clean  the  
relevant
 
database
 
tables
 
and
 
insert
 
the
 
data
 
from
 
the
 
generated
 
dataset
 
file. 3.  Run  Tests  via  Maven: Execute  the  tests  using  the  Maven  build  lifecycle  (e.g.,  by  running  mvn  test).  Maven  compiles  the  code,  downloads  dependencies,  and  triggers  the  JUnit  tests. 4.  Execute  Test  Logic  and  Verify  Results: The  test  code  performs  database  operations  (e.g.,  
calling
 
a
 
method
 
that
 
inserts
 
a
 
new
 
record).
 
Finally,
 
DBUnit
 
is
 
used
 
to
 
assert
 
that
 
the
 
final
 
state
 
of
 
the
 
database
 
matches
 
an
 
expected
 
dataset,
 
confirming
 
the
 
operation
 
was
 
successful. 
This  integrated  workflow  provides  a  powerful  foundation  for  automated,  repeatable,  and  reliable  
database
 
testing.
 
--- Page 20 ---
4.  Best  Practices  
a.  Dataset  Management  
●  Keep  Datasets  Small: Use  the  smallest  dataset  necessary  to  validate  a  specific  piece  of  
functionality. ●  Use  Realistic  Data: Generate  data  that  reflects  real-world  scenarios  to  uncover  more  
meaningful
 
bugs. ●  Version  Control  Datasets: Store  your  dataset  files  in  a  version  control  system  (like  Git)  
alongside
 
your
 
test
 
code. ●  Separate  Datasets: Create  different  datasets  for  different  test  purposes  (e.g.,  one  for  testing  
inserts,
 
another
 
for
 
testing
 
updates). 
b.  Test  Design  
●  Ensure  Test  Isolation: Each  test  should  be  independent  and  not  rely  on  the  state  left  by  a  
previous
 
test.
 
Use
 
DBUnit's
 
setup/teardown
 
capabilities
 
to
 
reset
 
the
 
database. ●  Start  with  a  Clean  State: Always  begin  tests  from  a  known,  clean  database  state. ●  Write  Meaningful  Assertions: Verify  not  just  that  the  code  runs,  but  that  it  produces  the  
correct
 
changes
 
in
 
the
 
database. ●  Include  Negative  Test  Cases: Test  scenarios  where  errors  are  expected  (e.g.,  violating  a  
unique
 
constraint). 
c.  Data  Generation  
●  Maintain  Referential  Integrity: Ensure  that  foreign  key  relationships  are  respected  in  the  
generated
 
data. ●  Use  Realistic  Distributions: Generate  data  that  mimics  the  statistical  distribution  of  
production
 
data. ●  Version  Control  Schemas: Save  and  version  control  the  schemas  used  to  generate  data  in  
Mockaroo. 
 
 
 
 
 
--- Page 21 ---
References  
LambdaTest.  (n.d.).  Database  testing.  LambdaTest.  Retrieved  from https://www.lambdatest.com/learning-hub/database-testing Katalon.  (n.d.).  Database  testing.  Katalon.  Retrieved  from https://katalon.com/resources-center/blog/database-testing GeeksforGeeks.  (n.d.).  Database  testing  –  Software  testing.  Retrieved  from  https://www.geeksforgeeks.org/database-testing/ Mockaroo.  (n.d.).  Official  documentation:  Test  data  generation.  Retrieved  from https://mockaroo.com/ DbUnit.  (n.d.).  About  DbUnit.  Retrieved  from  https://dbunit.sourceforge.net/  